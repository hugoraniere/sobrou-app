import { supabase } from '@/integrations/supabase/client';
import type { BlogPost, BlogTag, CreateBlogPostData, UpdateBlogPostData } from '@/types/blog';

export class BlogService {
  // Blog Posts
  static async getBlogPosts(): Promise<BlogPost[]> {
    const { data, error } = await supabase
      .from('blog_posts')
      .select(`
        *,
        tags:blog_post_tags(
          tag:blog_tags(*)
        )
      `)
      .order('published_at', { ascending: false });

    if (error) throw error;

    return data.map(post => ({
      ...post,
      tags: post.tags.map((t: any) => t.tag)
    }));
  }

  static async getBlogPost(id: string): Promise<BlogPost | null> {
    const { data, error } = await supabase
      .from('blog_posts')
      .select(`
        *,
        tags:blog_post_tags(
          tag:blog_tags(*)
        )
      `)
      .eq('id', id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }

    return {
      ...data,
      tags: data.tags.map((t: any) => t.tag)
    };
  }

  static async createBlogPost(postData: CreateBlogPostData): Promise<BlogPost> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error('User not authenticated');

    const { tags, ...blogPostData } = postData;

  // Create the blog post (slug will be auto-generated by trigger)
    const { data: post, error: postError } = await supabase
      .from('blog_posts')
      .insert({
        title: blogPostData.title,
        subtitle: blogPostData.subtitle,
        content: blogPostData.content,
        cover_image_url: blogPostData.cover_image_url,
        user_id: user.user.id,
        slug: '' // Will be auto-generated by trigger
      })
      .select()
      .single();

    if (postError) throw postError;

    // Handle tags
    if (tags && tags.length > 0) {
      await this.updatePostTags(post.id, tags);
    }

    return await this.getBlogPost(post.id) as BlogPost;
  }

  static async updateBlogPost(postData: UpdateBlogPostData): Promise<BlogPost> {
    const { id, tags, ...updateData } = postData;

    // Update the blog post
    const { error: postError } = await supabase
      .from('blog_posts')
      .update(updateData)
      .eq('id', id);

    if (postError) throw postError;

    // Handle tags if provided
    if (tags !== undefined) {
      await this.updatePostTags(id, tags);
    }

    return await this.getBlogPost(id) as BlogPost;
  }

  static async deleteBlogPost(id: string): Promise<void> {
    const { error } = await supabase
      .from('blog_posts')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }

  // Tags
  static async getTags(): Promise<BlogTag[]> {
    const { data, error } = await supabase
      .from('blog_tags')
      .select('*')
      .order('name');

    if (error) throw error;
    return (data || []).map((tag: any) => ({
      ...tag,
      slug: tag.slug || tag.name.toLowerCase().replace(/\s+/g, '-')
    }));
  }

  static async createTag(name: string): Promise<BlogTag> {
    const slug = name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim();

    const { data, error } = await supabase
      .from('blog_tags')
      .insert({ name, slug })
      .select()
      .single();

    if (error) throw error;
    return {
      ...data,
      slug: (data as any).slug || slug
    };
  }

  static async updateTag(id: string, name: string): Promise<BlogTag> {
    const slug = name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim();

    const { data, error } = await supabase
      .from('blog_tags')
      .update({ name, slug })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return {
      ...data,
      slug: (data as any).slug || slug
    };
  }

  static async deleteTag(id: string): Promise<void> {
    // First, remove tag associations from posts
    await supabase
      .from('blog_post_tags')
      .delete()
      .eq('tag_id', id);

    // Then delete the tag
    const { error } = await supabase
      .from('blog_tags')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }

  static async getOrCreateTags(tagNames: string[]): Promise<BlogTag[]> {
    const existingTags = await this.getTags();
    const existingTagNames = existingTags.map(tag => tag.name.toLowerCase());
    
    const newTagNames = tagNames.filter(name => 
      !existingTagNames.includes(name.toLowerCase())
    );

    // Create new tags
    const newTags = await Promise.all(
      newTagNames.map(name => this.createTag(name))
    );

    // Return all tags (existing + new)
    const allTags = [...existingTags, ...newTags];
    return tagNames.map(name => 
      allTags.find(tag => tag.name.toLowerCase() === name.toLowerCase())!
    );
  }

  // Post-Tag relationships
  private static async updatePostTags(postId: string, tagNames: string[]): Promise<void> {
    // Get or create tags
    const tags = await this.getOrCreateTags(tagNames);

    // Remove existing tags for this post
    await supabase
      .from('blog_post_tags')
      .delete()
      .eq('post_id', postId);

    // Add new tags
    if (tags.length > 0) {
      const { error } = await supabase
        .from('blog_post_tags')
        .insert(
          tags.map(tag => ({
            post_id: postId,
            tag_id: tag.id
          }))
        );

      if (error) throw error;
    }
  }

  // Storage
  static async uploadImage(file: File, path?: string): Promise<string> {
    const fileExt = file.name.split('.').pop();
    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
    const filePath = path ? `${path}/${fileName}` : fileName;

    const { data, error } = await supabase.storage
      .from('blog')
      .upload(filePath, file);

    if (error) throw error;

    const { data: publicUrl } = supabase.storage
      .from('blog')
      .getPublicUrl(data.path);

    return publicUrl.publicUrl;
  }

  // Analytics methods
  static async getBlogOverallStats(): Promise<{ total_posts: number; total_views: number; total_comments: number }> {
    const { data, error } = await supabase.rpc('get_blog_overall_stats');

    if (error) {
      throw new Error(`Failed to fetch overall blog stats: ${error.message}`);
    }

    const stats = data?.[0] || { total_posts: 0, total_views: 0, total_comments: 0 };

    return {
      total_posts: Number(stats.total_posts) || 0,
      total_views: Number(stats.total_views) || 0,
      total_comments: Number(stats.total_comments) || 0
    };
  }

  static async getTopViewedPosts(limit: number = 5): Promise<Array<{ id: string; title: string; view_count: number }>> {
    const { data, error } = await supabase.rpc('get_blog_post_stats');

    if (error) {
      throw new Error(`Failed to fetch top viewed posts: ${error.message}`);
    }

    return (data || [])
      .sort((a: any, b: any) => Number(b.view_count) - Number(a.view_count))
      .slice(0, limit)
      .map((post: any) => ({
        id: post.id,
        title: post.title,
        view_count: Number(post.view_count) || 0
      }));
  }

  static async getTopCommentedPosts(limit: number = 5): Promise<Array<{ id: string; title: string; comment_count: number }>> {
    const { data, error } = await supabase.rpc('get_blog_post_stats');

    if (error) {
      throw new Error(`Failed to fetch top commented posts: ${error.message}`);
    }

    return (data || [])
      .sort((a: any, b: any) => Number(b.comment_count) - Number(a.comment_count))
      .slice(0, limit)
      .map((post: any) => ({
        id: post.id,
        title: post.title,
        comment_count: Number(post.comment_count) || 0
      }));
  }

  static async getUserBlogStats(userId: string): Promise<{
    total_posts: number;
    total_views: number;
    avg_views_per_post: number;
    total_comments: number;
  }> {
    const { data, error } = await supabase
      .rpc('get_user_blog_stats', { target_user_id: userId });

    if (error) {
      throw new Error(`Failed to fetch user blog stats: ${error.message}`);
    }

    const stats = Array.isArray(data) && data.length > 0 ? data[0] : { total_posts: 0, total_views: 0, avg_views_per_post: 0, total_comments: 0 };
    return {
      total_posts: Number(stats.total_posts) || 0,
      total_views: Number(stats.total_views) || 0,
      avg_views_per_post: Number(stats.avg_views_per_post) || 0,
      total_comments: Number(stats.total_comments) || 0
    };
  }

  // Role checks
  static async isAdmin(): Promise<boolean> {
    const { data, error } = await supabase
      .rpc('is_admin');

    if (error) throw error;
    return data;
  }

  static async isEditor(): Promise<boolean> {
    const { data, error } = await supabase
      .rpc('is_editor');

    if (error) throw error;
    return data;
  }

  static async canAccessAdmin(): Promise<boolean> {
    try {
      const [isAdmin, isEditor] = await Promise.all([
        this.isAdmin(),
        this.isEditor()
      ]);
      return isAdmin || isEditor;
    } catch (error) {
      return false;
    }
  }

  // User management (admin only)
  static async searchUsers(
    searchTerm: string = '',
    roleFilter: string = 'all',
    sortBy: string = 'created_at',
    sortOrder: string = 'DESC'
  ): Promise<any[]> {
    const { data, error } = await supabase
      .rpc('search_users', { 
        search_term: searchTerm,
        role_filter: roleFilter,
        sort_by: sortBy,
        sort_order: sortOrder
      });

    if (error) throw error;
    return data || [];
  }

  static async manageUserRole(
    userId: string, 
    role: 'admin' | 'editor', 
    action: 'add' | 'remove'
  ): Promise<boolean> {
    const { data, error } = await supabase
      .rpc('manage_user_role', {
        target_user_id: userId,
        target_role: role,
        action: action
      });

    if (error) throw error;
    return data;
  }

  // Public blog methods
  async getPublicBlogPosts(searchTerm?: string, pageSize: number = 10, pageOffset: number = 0): Promise<BlogPost[]> {
    console.log('[BlogService] Fetching public blog posts:', { searchTerm, pageSize, pageOffset });
    
    try {
      const { data, error } = await supabase
        .rpc('get_public_blog_posts', {
          search_term: searchTerm || '',
          page_size: pageSize,
          page_offset: pageOffset
        });

      if (error) {
        console.error('[BlogService] Error fetching public blog posts:', error);
        throw error;
      }

      return data.map((post: any) => ({
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      }));
    } catch (error) {
      console.error('[BlogService] Error fetching public blog posts:', error);
      throw error;
    }
  }

  async getPublicBlogPost(postId: string): Promise<BlogPost | null> {
    console.log('[BlogService] Fetching public blog post:', postId);
    
    try {
      const { data, error } = await supabase
        .rpc('get_public_blog_post', {
          target_post_id: postId
        });

      if (error) {
        console.error('[BlogService] Error fetching public blog post:', error);
        throw error;
      }

      if (!data || data.length === 0) {
        return null;
      }

      const post = data[0];
      return {
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          slug: tag.slug || tag.name.toLowerCase().replace(/\s+/g, '-'),
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      };
    } catch (error) {
      console.error('[BlogService] Error fetching public blog post:', error);
      throw error;
    }
  }

  // Secure method to get public blog comments with masked emails
  async getPublicBlogComments(postId?: string): Promise<any[]> {
    console.log('[BlogService] Fetching public blog comments:', { postId });

    try {
      const { data, error } = await supabase
        .rpc('get_public_blog_comments', {
          target_post_id: postId || null
        });

      if (error) {
        console.error('[BlogService] Error fetching public blog comments:', error);
        throw error;
      }

      console.log('[BlogService] Blog comments fetched successfully:', data?.length || 0);
      return data || [];
    } catch (error) {
      console.error('[BlogService] Error fetching public blog comments:', error);
      throw error;
    }
  }

  async getPublicBlogPostBySlug(slug: string): Promise<BlogPost | null> {
    console.log('[BlogService] Fetching public blog post by slug:', slug);
    
    try {
      const { data, error } = await supabase
        .rpc('get_public_blog_post_by_slug', {
          target_slug: slug
        });

      if (error) {
        console.error('[BlogService] Error fetching public blog post by slug:', error);
        throw error;
      }

      if (!data || data.length === 0) {
        return null;
      }

      const post = data[0];
      return {
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          slug: tag.slug || tag.name.toLowerCase().replace(/\s+/g, '-'),
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      };
    } catch (error) {
      console.error('[BlogService] Error fetching public blog post by slug:', error);
      throw error;
    }
  }

  async toggleBlogPostLike(postId: string, userId?: string): Promise<boolean> {
    console.log('[BlogService] Toggling blog post like:', { postId, userId });
    
    try {
      const { data, error } = await supabase
        .rpc('toggle_blog_post_like', {
          target_post_id: postId,
          user_id_param: userId || null,
          ip_address_param: userId ? null : 'anonymous'
        });

      if (error) {
        console.error('[BlogService] Error toggling blog post like:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('[BlogService] Error toggling blog post like:', error);
      throw error;
    }
  }

  async recordBlogPostView(postId: string, userId?: string): Promise<void> {
    console.log('[BlogService] Recording blog post view:', { postId, userId });
    
    try {
      const { error } = await supabase
        .from('blog_post_views')
        .insert({
          post_id: postId,
          user_id: userId || null,
          ip_address: userId ? null : 'anonymous'
        });

      if (error) {
        console.error('[BlogService] Error recording blog post view:', error);
        throw error;
      }
    } catch (error) {
      console.error('[BlogService] Error recording blog post view:', error);
      throw error;
    }
  }

  // Featured Posts Management
  static async getActiveFeaturedPost(): Promise<any | null> {
    const { data, error } = await supabase
      .rpc('get_active_featured_post');

    if (error) {
      console.error('Error fetching featured post:', error);
      return null;
    }

    return data?.[0] || null;
  }

  static async createFeaturedPost(featuredPostData: any): Promise<any> {
    const { data, error } = await supabase
      .from('blog_featured_posts')
      .insert(featuredPostData)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  static async updateFeaturedPost(id: string, updateData: any): Promise<any> {
    const { data, error } = await supabase
      .from('blog_featured_posts')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  static async deleteFeaturedPost(id: string): Promise<void> {
    const { error } = await supabase
      .from('blog_featured_posts')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }

  static async getFeaturedPosts(): Promise<any[]> {
    const { data, error } = await supabase
      .from('blog_featured_posts')
      .select(`
        *,
        blog_posts (
          title,
          subtitle,
          slug,
          cover_image_url,
          published_at
        )
      `)
      .order('display_order', { ascending: true });

    if (error) throw error;
    return data || [];
  }

  // Enhanced public methods with category support
  async getPublicBlogPostsByCategory(category?: string, pageSize: number = 10, pageOffset: number = 0): Promise<BlogPost[]> {
    console.log('[BlogService] Fetching posts by category:', { category, pageSize, pageOffset });
    
    try {
      let query = supabase
        .rpc('get_public_blog_posts', {
          search_term: '',
          page_size: pageSize,
          page_offset: pageOffset
        });

      const { data, error } = await query;

      if (error) {
        console.error('[BlogService] Error fetching posts by category:', error);
        throw error;
      }

      // Filter by category if provided (client-side filtering for now)
      let filteredData = data;
      if (category) {
        filteredData = data.filter((post: any) => 
          post.tags && post.tags.some((tag: any) => tag.name === category)
        );
      }

      return filteredData.map((post: any) => ({
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      }));
    } catch (error) {
      console.error('[BlogService] Error fetching posts by category:', error);
      throw error;
    }
  }

  async getAllTags(): Promise<any[]> {
    try {
      const { data, error } = await supabase
        .from('blog_tags')
        .select('*')
        .order('name');

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('[BlogService] Error fetching tags:', error);
      return [];
    }
  }

  async getRelatedBlogPosts(postId: string, limit: number = 3): Promise<BlogPost[]> {
    try {
      // Get the current post's tags
      const currentPost = await this.getPublicBlogPost(postId);
      if (!currentPost || !currentPost.tags || currentPost.tags.length === 0) {
        return [];
      }

      const tagNames = currentPost.tags.map(tag => tag.name);
      
      // Get posts with similar tags, excluding the current post
      const { data, error } = await supabase
        .rpc('get_public_blog_posts', {
          search_term: '',
          page_size: limit + 5, // Get extra to filter out current post
          page_offset: 0
        });

      if (error) throw error;

      // Filter posts that share tags with current post and exclude current post
      const relatedPosts = data
        .filter((post: any) => 
          post.id !== postId && 
          post.tags && 
          post.tags.some((tag: any) => tagNames.includes(tag.name))
        )
        .slice(0, limit);

      return relatedPosts.map((post: any) => ({
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      }));
    } catch (error) {
      console.error('[BlogService] Error fetching related posts:', error);
      return [];
    }
  }

  async getTagStats(): Promise<Array<{ name: string; count: number }>> {
    try {
      const { data, error } = await supabase
        .from('blog_post_tags')
        .select(`
          tag_id,
          blog_tags!inner(name)
        `);

      if (error) throw error;

      // Count tag occurrences
      const tagCounts: { [key: string]: number } = {};
      data.forEach((item: any) => {
        const tagName = item.blog_tags.name;
        tagCounts[tagName] = (tagCounts[tagName] || 0) + 1;
      });

      // Convert to sorted array
      return Object.entries(tagCounts)
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10); // Top 10 tags
    } catch (error) {
      console.error('[BlogService] Error fetching tag stats:', error);
      return [];
    }
  }

  async getFeaturedPosts(limit: number = 3): Promise<BlogPost[]> {
    try {
      const { data, error } = await supabase
        .rpc('get_public_blog_posts', {
          search_term: '',
          page_size: limit * 2, // Get extra to sort by likes
          page_offset: 0
        });

      if (error) throw error;

      // Sort by like count and return top posts
      const featuredPosts = data
        .sort((a: any, b: any) => (b.like_count || 0) - (a.like_count || 0))
        .slice(0, limit);

      return featuredPosts.map((post: any) => ({
        ...post,
        tags: Array.isArray(post.tags) ? post.tags.filter((tag: any) => tag && tag.id).map((tag: any) => ({
          id: tag.id,
          name: tag.name,
          created_at: tag.created_at || new Date().toISOString()
        })) : []
      }));
    } catch (error) {
      console.error('[BlogService] Error fetching featured posts:', error);
      return [];
    }
  }
}